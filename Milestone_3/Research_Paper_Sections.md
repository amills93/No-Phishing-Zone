### These are the sections of the final research paper.
## Abstract (Basic research paper abstract and is the Executive Summary).
Phishing, smishing, vishing… these attacks are often among the most simplistic to perform by malicious actors, and yet they can often have the most damaging consequences. Ransomware is on the rise, especially in the COVID-19 pandemic era, but did you know that a huge portion of ransomware attacks start with a simple phish? Most social engineering attacks follow the shotgun approach, meaning the attacker likes to send as many of them as possible in order to get a catch. Between a lack of focus and a lack of security training, the average Joe is unlikely to spot the difference between a fake link and a real one.
In a large business organization, an end-user might be instructed to undergo security awareness training courses to instill safe practices for working in the digital age. But apart from those people, the average person does not receive any kind of training. What if we could bridge this knowledge gap with security awareness tooling?
No-Phishing-Zone is a Google Chrome extension designed to scan for commonly used social engineering tricks and identify suspicious sending domains, language, key triggers, and perform link validation while a user browses the internet. No-Phishing-Zone will flag those suspicious items and notify the user of the malicious intent leaving the option to continue up to the user. Often users are merely trying to live their lives and do things as quickly as possible, so any tool that helps them stay safe is a good one. No-Phishing-Zone is meant to supplement a user’s safe browsing habits and catch suspicious behaviors which may have slipped by them.
The specific goals for No-Phishing-Zone are to deliver a tool that:
- Assists with spotting suspicious language which may be a social engineering attempt.
- Assist in vetting links as legitimate or as suspected to be malicious.
- Very that the sender of the email is not spoofing an address.
- Increase the overall safe browsing habits of a user, without having the ability to walk them through a cybersecurity training course.
## I. Background
Issue of phishing
- Brief history of phishing.

Though the date of the first phishing attack is not known, the practice originated sometime in the year 1995 on the America Online (AOL) internet chatroom and email service [2]. The attack has grown quite complex since then, but the fundamentals of the attack have stayed the same.
- Definition of phishing.

The National Institute of Science and Technology (NIST) defines Phishing as “A technique for attempting to acquire sensitive data, such as bank account numbers, through a fraudulent solicitation in email or on a Web site, in which the perpetrator masquerades as a legitimate business or reputable person” [1].

## II. Introduction
Framing issue of phishing as a behavioral problem, not entirely a technical one.
- Delay between attack and fallout from attack.

As Phishing is taking advantage of a victim’s trust or lack of knowledge, it is not necessarily a technical attack as much as a behavioral problem. This is the reason why it can come in so many different forms (i.e. phishing, vishing, smishing), the attack is using technology to trick an individual into giving the attacker sensitive information. The sensitive information will then be used to log into the victims account later and the attacker will masquerade as the victim. This is a form of identity theft, and a successful phishing attack almost always leads to the victim having their identity stolen in some way. Much of the reason phishing was successful when the internet was in its infancy is the same reason why it is successful now; individuals are not familiar with the attack and do not know what to look out for, or what to be weary of. This can be especially difficult because the attack does not immediately result in blinking warnings or notifications, as there is usually a delay between a successful phishing attack and the victim realizing the fallout from the attack.
- Attackers’ techniques
•	Different types of attacks, and current state of situation should all be covered.

There are generally four different types of phishing attacks: Smishing, Vishing, Email Phishing, and Angler Phishing. Smishing is when phishing attacks are done over SMS messages, Vishing is done over voice telephone calls, Angler Phishing is a newer attack that targets victims over social media, and finally is email phishing which is the subject of this paper [3]. While the method of the attack may change, the deception of the attacker convincing the victim that sensitive information needs to be given over is a common thread.
- How these attacks happen.
	- Why these attacks happen.
	- Genesis of our project idea and why defenses for these attacks are important.

Phishing attacks have been around since internet access has become widely available, and will continue to be around for the same reason; human weakness and ignorance of the danger of others online. The complexity of the internet and computers is an issue for many users, young and old, rich and poor, and this is why phishing attacks are successful. The integration of computers into our daily lives has facilitated a need of them to live our lives, but fully understanding how these systems work is not imperative to using them. Here in lies the danger. This is the reason we focused on this subject for this project, because while some have a good ability to detect a “phishy” email, not everyone does. No Phishing Zone was designed to help fill this skills gap, so that everyone can use web email more securely.

- Impacts we believe this will have in the current situation

We believe that the web browser extension that we created will help to lower the risks of individuals falling for phishing attacks, by showing them if a link is likely safe or not. While this is not a silver bullet for the issue of phishing, it can greatly help someone that lacks the skills of identifying phishy emails.
Related works
-	Brief recap of literature review.

## III. Methodology
For the semester, the initial proposed scope of our project was narrowed due to our initial lack of web development experience and our lack of familiarity with Chrome Extension Development. We initially started with trying to create a cross-browser extension that can ingest a user’s active, open email, then identify grammar errors, malicious links, and determine if the email came from a malicious. Sender. In addition to cross-browser support, this was meant to be work with all email vendors. Upon starting the project, we realized that creating a cross-browser extension would not be feasible due to the semester's time constraint, so we opted for a Google Chrome Extension. Similarly, we learned that we would not be able to have the extension work across multiple webmail clients due to the obfuscation of class and id variables, eventually deciding on creating an extension that works with the Google Mail web client. Due to the difficulty of parsing the Google Mail DOM page, we decided against the idea of identifying grammar errors and only focus on the sender's email and any URLs in the body. The system context diagram below shows how the average user would interact with our extension. The extension will only execute when a user is inside the `https://mail.google.com/` domain.

![system context diagram](../Milestone_2/Diagrams/System-Context-Diagram.PNG)
### A. Identifying the Emails Sender and Body
The next logical step was to identify the email sender's address and any URLs inside the body of the email. To do this, we exported a copy of the DOM to a text file and then manually sorted through the HTML code to look for key elements.  Doing this, we learned that Google Mail stores the sender's email address under a `<span>` tag with a class of `go`.   This method of identifying the URLs inside the body of the email proved to be more difficult than initially planned.   The method involved starting a search at a paragraph or known URL in the body and work our way up to the outermost `<div>` tag, while not including the URLs for the inbox on the side or at the bottom of the webpage. Through trial and error, mainly by outputting different `<div>` classes or ids to the console, we eventually discovered that the `<div>` tag with an id of `:2h` contained the body of the email. We confirmed with the other members of our team that the `go` class and `:2h` id were the same across accounts, browsers, and sessions before we began parsing the data inside the tags.

### B. Windows Event Listeners
Chrome Extensions utilize Content Scripts to execute JavaScript inside the context of a webpage by using the standard Document Object Model (DOM) [4]. We utilized these content scripts to read in the elements from the `DOM`, then make changes based on what ingested elements are. Content Scripts rely on window events to execute code, so we had to add an event listener to look for `popstate` events because each opening of an email inside a mailbox stays within the `https://mail.google.com/mail/u/0/#` URL. We initially used the `load` event listener but discovered such a technique would only work on page refreshes. Because the opening of a new mail does not trigger a `load` event, we had to listen for active history entry changes [5].  Refreshing the browser does not trigger the `popstate` event listener, so we had to keep the `load` listener so we can catch and execute our code on both events.

### C. Parsing the Email and URLs
Once the event listeners were found to be operational, we created a function to prase email address and another function to parse the list of URLs inside the `content.js` file. Our `ValidateEmail` function took the `<span>` tag with the class `go` and stored the `innerText` of the object in a `String` after stripping off the `<` and `>` characters before attempting validation. The URLs are sent to the `ValidateURLS` function where we had to create a `NodeList` of all `a` tags in the URL object. We then looped through each `a` tag in the `NodeList` and attempted to validate.

### D. Allow/Deny List vs API
The team’s initial plan was to use allow and deny lists for known malicious or known valid domains. We began building out our lists, however we encountered various issues finding available open-source lists. Websites like PhishTank.com offer ways for users to verify if a link is a known phish, but the site requires an account to access their API and registration was unfortunately closed [10]. We were able to download an older list of known phishing URLs from Phishtank but there were no timestamps showing the last time the list was updated. We were able to register for an API key through ThreatCenter Labs which allowed us to download a `.txt` file of known malicious domains that were said to be updated regularly [11]. We began developing our extension so that it could read in data from those text files, then use the JavaScript `indexOf(index)` function where `index` was the email addresses’ domain or a URL from the body of the email. This method seemed partially effective, and we were able to flag potentially malicious domains, however several bugs occurred wherein an email address from UPS (ups.com) or RedFin (redfin.com) (which we know are not malicious) were being flagged as malicious because they are not on the allow lists. We knew we would need to manually or programmatically update our allow list to account for new non-malicious domains. Another issue we ran into was the `indexOf(index)` function was producing a large number of false positives as it checked if `index` was a subset of a known malicious domain on our deny list. Using redfin.com as an example, `indexOf(index)` would return true since the string redfin is a subset of `freestar-redfin-tagan.adlightning.com` a known malicious domain. Similarly, ups.com was being marked as malicious because it is a subset of the string `fuyagroups.com` which was also on our deny list. To remedy these bugs, we would either manually add the redfin.com or ups.com domains to the allow list or develop a new way for comparing strings without the use of `indexOf(index)`. Due to these issues, we eventually decided against the use of an allow/deny list and found an API through IPQualityScore that allowed standard users to register for a free account with 200 API calls a day and 5,000 API calls a month [9].  This forced us to re-design our extension so that it can work with an API.  For us, the the benefits of a real-time malicious URL and email validator outweighed the time it took to re-code our extension. We felt the benefits and richness of the APIs response values would help further give the user a fuller experience when using our extension. The container diagram below shows how our extension interacts with the user, Google Mail client, and the IPQualityScore API.

![container diagram](../Milestone_2/Diagrams/Container-Diagram.PNG)

### E. Validating Senders URL and Email Address
When we began implementing the API, we discovered that API calls are not allowed inside Content Scripts.  To counter this, we tried using `jsonp`, `XMLHttpReqests`, and `jQuery JSON request` yet could not find a functioning workaround. Upon further research, it seemed that the use of a background script was needed to communicate with an external API [7]. We created a `background.js` file which would communicate with our `content.js` file via messages passing, where the `content.js` file would send the email and URL to `background.js`, then `background.js` makes the API call which sends the response back to the `content.js` file. Background scripts allow for a single listener, so we needed to devise a way to pass a `type` variable that helps distinguish between an email and URL, as each goes to different APIs. Since Chrome message passing allows for `json` strings we simply added `{"type": "type", "pieceToValidate": pieceToValidate}` to the `sendMessage` function where the `type` was either `email` or `URL`. This change allows for the appropriate API request and returns the appropriate response to the open `listener` in the content script. Since the background script makes the API call, we then validate the email or URL based on the response inside the background script and send back a `true` or `false` based on the `json` response values. For email, we chose to look at whether the email was valid, if it belonged to a temporary or disabled mail server, and the overall mail score according to IPQualityScore API documentation [8]. For URLs, IPQualityScore offers a similar API response set where we checked to see if the URL was used for phishing, malware, viruses, spam, or if it has been parked [12]. Before we send the URL to the background script, we had to format it per IPQualityScores API documentation and replace `https:// with https%3A%2F%2F`. We used the regex `/^https?:\/\//` alongside the replace function to ensure `http` or `https` of all URL strings are replaced before passing the URL to the background script for the API call. The IPQualityScore API responses were used to determine if a URL or email should be flagged as potentially malicious.  Based on the determination, the extension highlights the URL/email red for malicious, green for validated safe, and yellow for potentially suspicious.  Information regarding our risk rating and color schema shows up in the `popup.html` file so a standard user can see what each color or number means. We spent several weeks discussing the different API responses we would use without making our extension too strict by flagging everything as potentially malicious. This meant limiting the number of parameters used and rely on the `risk_score` response to ensure the extension is still providing users with a rich experience. We also appended the Risk Score next to the URL or email to give the user a better understanding of why it was highlighted the way it was. Some of the email URLs do not show a risk score due to them having an image `childNode` inside the `<a>` tag.  So as not to remove the image and replace it with a risk score, it was decided against appending the risk score for embedded image links. Future work can explore how embedded image links could have the risk score manipulated on top of the. To get a better visual representation of our extension refer to the component diagram below to see how our extension interacts with the external API.

![component diagram](../Milestone_2/Diagrams/Component-Diagram.PNG)

### F. Testing and Verification
The team decided to conduct only developmental testing because of time constraint, however, the project team ensured that testing and verification of the solution produced the expected outcome. The outcome come of the testing and verification is as described aboved, though we did not involve the use of external testers, or stakeholders but mainly supervisory validation which was observed during the development of the NPZ solution. In addition, no case study was conducted but we hope that during or in our future updates to engage some external users - possibly both professionals and non-professional tester to review the usability and conduct adequate survey to rate features and capabilities or the impact the solution will have on not too savvy technology users.

## IV. Results

The advantages of packaging our tool as an open sourced, freely available, lightweight browser extension for the most popular browser on the market are numerous.  It  allows this tool to reach a wider audience, with no barrier of cost or technology, and no burden towards an individual who is curious enough to quickly try the program.  The tool itself is also innovative, with little competition in the free, browser extension spaces our team seeks to occupy.  Most known anti-phishing products exist holistically in the business sector or are costly to use at home.  No Phishing Zone is neither of those, it can be used anywhere by anyone for no charge.  In essence, the No Phishing Zone could be the Grammarly of social engineering defense if it saw continued development.  Rather than a tool to negate basic grammar mistakes, No Phishing Zone can negate basic digital safety mistakes.  A spell checker does little to improve your skills in language, but it does offer a second set of eyes to prevent you from sending an embarrassing, mistyped email.  No Phishing Zone is also not a replacement for proper digital hygiene or safe cyber habits, for no tool can truly replace education.  However, with the ever-increasing scale of social engineering attacks, a built-in browse tool that can help point out clues that a vulnerable user may have missed is clearly an advantage worth exploring.

Determining the efficacy of the implementation of anti-phishing protection is more nebulous.  Without a full feature deploy of our original scope, and with an observable test audience over a year-long period, an accurate quantitative analysis cannot be performed.   We simply do not have the data, and do not wish to overestimate our effectiveness.  However, we can compare this tool to comparable techniques in an enterprise environment.  Many large organizations have built-in spam, phishing, and suspicious website protection which limits a user’s ability to be victimized.  These defenses are used for a reason, they work.  And they are not used in isolation, they are often used in combination with cybersecurity awareness training material distributed to users within the organization.  This is to say that these organizations understand that being cyber-aware does not mean that you care about cyber or are incapable of making mistakes.  The additional stop-gap security controls compliment the training as a helping hand.  No Phishing Zone, in practice, achieves this at a small scale.  An email sender or contained URL’s validity or lack thereof are successfully checked through No Phishing Zone, and the user is offered an extra security control to protect themselves as they browse the internet.  

## V. Future Work and Conclusion
### A. Future Work
The email and URL API endpoints offer more options that a future user could easily implement in our Chrome Extension to provide more of an analysis, to see the full list of supported API response fields refer to the Email API Documentation and URL API Documentation [9]. Future work could expand on what we did by implementing a more robust analysis of an email address or URL. IPQualityScore also offers a reporting feature where users can report malicious URLs or Emails. Future work could implement this reporting feature into the extensions `popup.html` so suspected links can be added to the IPQualityScores database. Since IPQualityScore offers a full fraud suite of tools with dedicated APIs we could expand on our application and focus on phishing and malicious links across all websites, however, the limited amount of API calls offered by IPQualityScore would not be able to support that on the free subscription model. Future researchers could build their own database of known malicious domains, similar to what is offered by IPQualityScore, to not be limited by the daily API call limit or further research can be done on other open-source APIs that do not have a daily limit. We were able to find several sites that contained updated lists of known malicious URLs, these lists can be compiled into a single allow list and hosted inside the No-Phishing-Zone Chrome Extension folder and updated on a semi-regular basis however this was deemed out of scope for our semester project. Implementing our own allow/deny list would eliminate the reliance on a 3rd parties API, however, the richness of the API and responses offered seemed to align with the scope of our semester project.

Due to the timeframe of the semester we had to limit our scope to only focus on Chrome Extensions and the Google Email Web Client. Future work can further develop our Extension and expand support to other web browsers and other email web clients. Due to the obfuscation of the DOM elements that identify the sender's email address and the body of the email we were only able to identify the `class` and `ids` for Google Emails. However, we were able to verify that these `class` and `ids` are unique to all Gmail accounts across multiple browsers. Future researchers can identify the same unique identifiers and apply support to online mail clients like Outlook or Yahoo. Our extension does not analyze attachments in emails, future work can be done to vet the authenticity of an attachment and see if it is malicious or not. Currently, we just rely on the fact that if the email is from a suspicious sender it is assumed the attachment is malicious. We also used version 2 of the `manifest.json` due to its support of background pages and more importantly `jQuery` in background pages. Future work would see that the `manifest` version is updated to version 3, however that would require more time since we would have to re-work how our application does API calls in the background page. Manifest version 2 is currently will be end of life (EOL) as of January 2023 [13].

### B. Conclusion
Our development on No Phishing Zone concludes with a functioning foundation for what we wanted a social engineering prevention tool should be.  It is free, open, easily installed, and available on the most used browser and email client in the world.  Our preliminary research into existing toolsets showed an apparent deficiency in non-business grade tools.  Numerous large enterprises use extensive in-house or procured software systems to perform these functions at a large scale.  However, that shows a disparity in available security controls for the common person.  Malicious actors surely target businesses and large organizations with great fervor, but attacks on individuals in their private lives are just as suspectable to attack.

The No Phishing Zone is free and lightweight Chrome browser extension that anyone can use.  The extension successful ingests a user’s email, parses it, then offers protection to the user by way of marking up the email based on suspected criteria.  A potentially malicious hyperlink, or a suspicious email sender, can be flagged as a form of warning to keep the user safe.  Whether the user is a trained IT professional who may be browsing to quickly to notice the suspicious nature of the email, or if the user has no proficiency in safe browsing habits, the No Phishing Zone serves as a supplementary security system to assist them in their daily lives.  A tool such as this, especially if development is continued, could help bridge the gap in digital hygiene amongst those browsing online.


## VI. Citations
[1] R. Shirley. 2007. RFC 4949 - internet security glossary, version 2. (August 2007). Retrieved April 25, 2022 from https://datatracker.ietf.org/doc/html/rfc4949

[2] KnowBe4. 2022. History of phishing. (2022). Retrieved April 25, 2022 from https://www.phishing.org/history-of-phishing

[3] Luke Irwin. 2022. The 5 most common types of phishing attack. (March 2022). Retrieved April 25, 2022 from https://www.itgovernance.eu/blog/en/the-5-most-common-types-of-phishing-attack

[4]“Content scripts,” Chrome Developers.  [Online]. Available: https://developer.chrome.com/docs/extensions/mv2/content_scripts/

[5]“Window: popstate event - Web APIs | MDN.”  [Online]. Available: https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event

[6]“Fraud Prevention | Bot Detection | Bot Protection | Prevent Fraud with IPQS.”  [Online]. Available: https://www.ipqualityscore.com

[7]“Manage events with background scripts,” Chrome Developers.  [Online]. Available: https://developer.chrome.com/docs/extensions/mv2/background_pages/

[8]IPQualityScore.com, “Email Validation API Documentation | IPQualityScore.com.”  [Online]. Available: https://www.ipqualityscore.com/documentation/email-validation/overview

[9]IPQualityScore.com, "IPQualityScore Homepage | IPQualityScore.com" [Online]. Available: https://www.ipqualityscore.com/documentation/overview

[10]“PhishTank,” PhishTank.  [Online]. Available: https://www.phishtank.com/

[11]“CRDF Threat Center,” CRDF Threat Center API.  [Online]. Available: https://threatcenter.crdf.fr/

[12]IPQualityScore.com, “Malicious URL Scanner API Documentation | IPQualityScore.com.”  [Online]. Available: https://www.ipqualityscore.com/documentation/malicious-url-scanner-api/overview

[13]“The transition of Chrome extensions to Manifest V3,” Chrome Developers. [Online]. Available: https://developer.chrome.com/blog/mv2-transition/
